{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Reorder and Split</title>
    <link rel="stylesheet" href="{% static 'style.css' %}">

  <style>
    .pdf-page {
      transition: transform 0.2s ease-in-out;
      margin: 5px;
      display: inline-block;
      position: relative;
    }

    .placeholder {
      border: 2px dashed #ccc;
      background: #f9f9f9;
      width: 100px; /* Same size as preview pages */
      height: 140px; /* Adjust according to your preview size */
      display: inline-block;
      margin: 5px;
      animation: fadeIn 0.2s ease-in-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    #pdf-preview {
      display: flex;
      flex-wrap: wrap;
    }

    .delete-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: red;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div>
    <h1>PDF Drag & Drop - Reorder and Download</h1>
    <div id="drop-area" style="width: 100%; height: 200px; border: 2px dashed #ccc;">
      <p>Drag and drop your PDF files here</p>
    </div>
    <br>
    <button id="download-reordered">Download Re-ordered PDF</button>
    <button id="clear-all">Clear All Pages</button>
    <br><br>
    <button id="zoom-in">Zoom In</button>
    <button id="zoom-out">Zoom Out</button>
    <br><br>
    <div id="pdf-preview"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script>
    let originalPdf = null; // Stores the main PDF document
    let pageOrder = []; // Stores the order of pages in the preview

    const dropArea = document.getElementById("drop-area");
    const pdfPreview = document.getElementById("pdf-preview");
    const zoomIn = document.getElementById("zoom-in");
    const zoomOut = document.getElementById("zoom-out");
    const downloadReordered = document.getElementById("download-reordered");
    const clearAll = document.getElementById("clear-all");

    let zoomScale = 0.6; // Initial zoom scale

    // Handle PDF drop
    dropArea.addEventListener("drop", async (e) => {
      e.preventDefault();
      const files = e.dataTransfer.files;
      for (const file of files) {
        if (file.type === "application/pdf") {
          const newPdfBytes = await file.arrayBuffer();
          const newPdf = await PDFLib.PDFDocument.load(newPdfBytes);

          // If originalPdf doesn't exist, set it to the newPdf
          if (!originalPdf) {
            originalPdf = await PDFLib.PDFDocument.create();
          }

          // Append pages from the new PDF to the existing originalPdf
          const copiedPages = await originalPdf.copyPages(newPdf, newPdf.getPages().map((_, i) => i));
          copiedPages.forEach((page) => {
            originalPdf.addPage(page);
          });

          // Re-render the pages in the preview area
          renderPreview(newPdf);
        }
      }
    });

    // Function to render the PDF preview
    function renderPreview(pdfDoc) {
      pdfDoc.getPages().forEach((page, index) => {
        renderPage(page, index);
      });
    }

    // Function to render each individual page
    async function renderPage(page, pageIndex) {
      const viewport = page.getViewport({ scale: zoomScale });
      const canvas = document.createElement("canvas");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const context = canvas.getContext("2d");
      const renderContext = { canvasContext: context, viewport: viewport };

      const pageContainer = document.createElement("div");
      pageContainer.classList.add("pdf-page");
      pageContainer.dataset.pageNum = pageIndex;
      pageOrder.push(pageIndex);

      await page.render(renderContext).promise;

      // Append the canvas to the container
      pageContainer.appendChild(canvas);
      pdfPreview.appendChild(pageContainer);

      // Add delete button to remove the page
      const deleteBtn = document.createElement("button");
      deleteBtn.classList.add("delete-btn");
      deleteBtn.textContent = "x";
      deleteBtn.addEventListener("click", () => {
        pageContainer.remove();
        pageOrder.splice(pageOrder.indexOf(pageIndex), 1);
        updatePageOrder();
      });
      pageContainer.appendChild(deleteBtn);

      // Add drag-and-drop handlers
      let placeholder;
      pageContainer.draggable = true;

      pageContainer.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("text/plain", pageIndex);
        placeholder = document.createElement("div");
        placeholder.classList.add("placeholder");
        pageContainer.classList.add("dragging");
      });

      pageContainer.addEventListener("dragover", (e) => {
        e.preventDefault();
        const draggingElement = document.querySelector(".dragging");

        if (!draggingElement || pageContainer === draggingElement) return;

        if (!placeholder.parentNode) {
          pageContainer.parentNode.insertBefore(placeholder, pageContainer);
        }
      });

      pageContainer.addEventListener("drop", (e) => {
        e.preventDefault();
        const draggedPageIndex = parseInt(e.dataTransfer.getData("text/plain"));

        const draggingElement = document.querySelector(
          `.pdf-page[data-page-num="${draggedPageIndex}"]`
        );

        if (draggingElement) {
          pdfPreview.insertBefore(draggingElement, placeholder);
          updatePageOrder();
        }

        if (placeholder.parentNode) placeholder.remove();
      });

      pageContainer.addEventListener("dragend", () => {
        pageContainer.classList.remove("dragging");
        if (placeholder && placeholder.parentNode) {
          placeholder.remove();
        }
      });
    }

    // Update the page order based on current DOM structure
    function updatePageOrder() {
      pageOrder = Array.from(pdfPreview.children)
        .filter((child) => child.classList.contains("pdf-page"))
        .map((child) => parseInt(child.dataset.pageNum, 10));
    }

    // Zoom In and Zoom Out
    zoomIn.addEventListener("click", () => {
      zoomScale += 0.1;
      reRenderPages();
    });

    zoomOut.addEventListener("click", () => {
      zoomScale = Math.max(0.1, zoomScale - 0.1);
      reRenderPages();
    });

    // Re-render pages when zoom changes
    function reRenderPages() {
      pdfPreview.innerHTML = '';
      const pdfDoc = originalPdf; // Get the original PDF
      pdfDoc.getPages().forEach((page, index) => {
        renderPage(page, index);
      });
    }

    // Download the reordered PDF
    downloadReordered.addEventListener("click", async () => {
      if (!originalPdf || pageOrder.length === 0) {
        alert("No pages to reorder.");
        return;
      }

      // Create a new PDF document for the reordered pages
      const newPdfDoc = await PDFLib.PDFDocument.create();
      for (const pageIndex of pageOrder) {
        const [page] = await newPdfDoc.copyPages(originalPdf, [pageIndex]);
        newPdfDoc.addPage(page);
      }

      // Save the reordered PDF
      const pdfBytes = await newPdfDoc.save();
      const blob = new Blob([pdfBytes], { type: "application/pdf" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "reordered.pdf";
      link.click();
    });

    // Clear all pages
    clearAll.addEventListener("click", () => {
      pdfPreview.innerHTML = '';
      pageOrder = [];
      originalPdf = null;
    });
  </script>
</body>
</html>



